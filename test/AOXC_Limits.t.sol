// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {AOXCTest} from "./AOXC.t.sol";

/**
 * @title AOXC Quantitative Policy Verification
 * @author AOXC Engineering Team
 * @notice Tests mathematical constraints including transaction velocity and inflation caps.
 * @dev Fully optimized for Fuzzing efficiency and zero linter warnings.
 */
contract AOXCLimitsTest is AOXCTest {

    /**
     * @notice Verifies the Daily Transfer Limit by executing multiple transactions.
     * @dev Splits the transfer to respect MaxTX while testing the aggregate daily ceiling.
     */
    function testLimitsVelocityDailyWindow() public {
        uint256 dailyLimit = proxy.dailyTransferLimit();
        uint256 maxTx = proxy.maxTransferAmount();
        
        // 1. Seed user1 with funds (Divided to respect MaxTX limit)
        vm.startPrank(admin);
        bool s1 = proxy.transfer(user1, maxTx);
        bool s2 = proxy.transfer(user1, dailyLimit - maxTx);
        assertTrue(s1 && s2, "Seeding failed");
        vm.stopPrank();

        // 2. Execute transfers from user1 to user2 up to the daily limit
        vm.startPrank(user1);
        bool r1 = proxy.transfer(user2, maxTx);
        bool r2 = proxy.transfer(user2, dailyLimit - maxTx);
        assertTrue(r1 && r2, "Transfer within limits failed");
        
        // 3. The next 1 wei must trigger a DailyLimit revert
        vm.expectRevert("AOXC: DailyLimit");
        bool success = proxy.transfer(user2, 1); 
        assertTrue(!success); 
        vm.stopPrank();
    }

    /**
     * @notice Invariant testing using Fuzzing to ensure MaxTX is enforced.
     * @param amount The random amount generated by the Fuzzer.
     * @dev Uses 'bound' instead of 'assume' to ensure the Fuzz engine always finds valid inputs.
     */
    function testFuzzVelocityLimitInvariance(uint256 amount) public {
        uint256 maxTx = proxy.maxTransferAmount();
        uint256 mintLimit = proxy.yearlyMintLimit();

        // FIX: Instead of rejecting numbers, we 'bound' them into our valid range.
        // Range: (maxTx + 1) to (mintLimit)
        uint256 boundedAmount = bound(amount, maxTx + 1, mintLimit);

        // Seeding: Admin mints the bounded amount
        vm.prank(admin);
        proxy.mint(user1, boundedAmount);

        // Execution: User attempts to transfer the amount in a single transaction
        vm.prank(user1);
        vm.expectRevert("AOXC: MaxTX");
        bool success = proxy.transfer(user2, boundedAmount);
        
        // Satisfaction for both logic and linter
        assertTrue(!success);
    }

    /**
     * @notice Validates the Yearly Inflation Cap policy and temporal reset.
     * @dev Ensures the 6% cap resets correctly after 365 days.
     */
    function testLimitsTemporalInflationCap() public {
        uint256 mintLimit = proxy.yearlyMintLimit();
        
        vm.startPrank(admin);
        // Exhaust the yearly quota
        proxy.mint(user1, mintLimit);
        
        // Attempting to mint 1 more wei must revert
        vm.expectRevert("AOXC: Inflation");
        proxy.mint(user1, 1);
        
        // Advance time by 365 days + 1 second
        skip(365 days + 1);
        
        // New epoch: Minting should now be successful
        proxy.mint(user1, 1e18); 
        
        assertEq(proxy.balanceOf(user1), mintLimit + 1e18);
        vm.stopPrank();
    }
}
